# 第二部分 静态链接

## 一、编译原理

编译和连接的过程合并到一起成为构建 Build。

## 二、编译的过程概览

c、c++源码文件，经过预编译、编译、汇编、链接。最终变成目标文件object file(.o文件)。 其中具体的过程为： 预编译：替换宏定义、#include替换等，得到xx.i
中间文件。也就是宏替换和文件包含相关。 编译：把xxx.i文件编译为.s 文件，得到汇编指令文件xxx.s。本质上是将高级语言翻译成汇编语言/机器语言。
汇编：把xxx.s文件，经过翻译得到机器指令文件，也就是目标文件object file。xxx.o。 链接：因为xxx.o只是目标文件，而不是可执行文件。所以需要经过ld链接器来得到最终的可执行文件。
链接器的工作过程就是把一大堆xxx.o文件，加上自己的源码生成的目标文件，链接起来为一个可执行文件a.out。

## 三、编译器做了什么

过程：扫描、语法分析、语义分析、源代码优化、汇编代码生成和目标代码优化。从源代码source code到目标代码 final target code。
对于Android来说，gradle文件或者java文件会经过编译器，得到.class文件，然后在加载到虚拟机中去执行。

### 3.1 语法分析

源代码会被扫描器 scanner 一个字符一个字符(ASCII码表？)
的记录到表中。得到一堆记号token。在扫描的过程中也就完成了此法分析。记号一般包含识别：关键字、标识符。
**疑问？？这个阶段会产生符号表？？？**
此法分析工具为lex，可通过自定义此法规则来完成此法分析。

### 3.2 语法分析

对扫描得到的记号表做语法分析，对每一个表达式生成语法树syntax tree。为什么是树？因为一个表达式可能会包含很多子表达式，所以生成树。树的每一个节点都是一个表达式。
只要节点中的表达式不合法，如括号不匹配，缺少操作符等，那么编译器就会报错。 语法分析工具yacc，可以根据规则完成语法分析。

### 3.3 语义分析

semantic analyzer。语法分析只能判断表达式是否合法，并不知道它具有什么含义。 语义分析分为静态时语义分析和动态语义分析。 静态语义分析：在编译期间通过编译器分析得到。static
semantic。包括声明和类型的匹配，类型的转换等。 动态语义分析：在运行期才能得到。dynamic semantic。除0就是一个运行期的语义分析。

经过语义分析，在语法树上加入了一些类型的标记。

### 3.4 中间语言的生成

在生成语法树之后，会对源码进行优化。比如2+6或被替换成8。 但是，编译器不会直接在语法树上进行优化。而是转成中间代码intermediate code后，再优化。
采用三地址法来表示，包含三个变量的地址。此时的中间代码虽然跟目标代码很像，但其实和平台无关，至此语法树就变成了顺序的代码结构。后面将中间代码翻译成目标代码即可。
因此，编译过程根据中间代码划分为前端和后端。 编译器前端：把源码生成生成中间代码。 编译器后端：把中间代码翻译成机器代码。
所以，对于跨平台的编译器而言，可以使用同一个前端，针对不同平台使用不同的后端编译。

### 3.5 目标代码生成和优化

源代码级优化器产生中间代码后，意味着接下来的过程都属于编译器后端。而编译器后端主要包括代码生成和目标代码优化。
代码生成器十分依赖于目标机器，会根据不同平台的CPU指令集、寄存器、不同的字长等信息，将中间代码生成对应的目标代码。

目标代码生成后，目标代码优化器会进行优化： 选择合适的寻址方式、乘法替换为唯一运算、删除多余指令等。 还有一些CPU平台新特性，也是有编译器优化来完成的。
真个过程非常复杂，因此，复杂的编译器能够支持所有平台的机器指令。

总结： 经过扫描、词法分析、语法分析、语义分析、源码代码优化、代码生成、目标代码优化最终得到目标机器代码，但此时，代码中的变量如某个变量或者函数入口还没有确定内存地址？
如果在一个编译单元，可以确定地址。但是，在不同的编译单元怎么办？ ？ 即，目标代码汇中有变量定义在其他的模块，怎么确定变量的地址？

事实上，定义在其他模块中的变量和函数在最终运行期的绝对地址需要在最终的链接阶段才能被确定。 因此，编译器会把源代码编译为未链接的目标文件，而链接器将这些目标文件链接成可执行文件。

## 四、链接器

我的理解: 连接的本质就是调整符号所对应的地址！？？？

- 重定位relocation和符号symbol

第一批程序员写代码就跟现在计算机的执行过程是一样的。 需要程序员手动的去记住某条指令的地址。比如第一条指令的地址是0，内容是跳转到第五条指令（地址是4
）。当在第五条指令前插入一个条指令后，那么第五条指令的地址就会变成6。因此，第五条指令的地址就需要重新来定位。这样的场景频繁存在，那么很是奔溃~~

因此，就发明了符号symbol。如用foo来表示一个函数。 当在该函数前插入一条指令后，肯定会导致该函数的地址发生变化。但是这个重定位的计算过程交给了汇编器来完成。程序员只关心foo 这个符号即可。
类似的，我们只要记住某个变量a即可，而不用去记住a变量对应的起始内存地址。

**所以用符号symbol来表示一个地址，这个地址表示一段子程序的起始地址(后面称为函数)，也可以表示一个变量的起始地址(因为变量有字节大小的)。**

- 代码组织架构

java
语言中，一个大型的项目肯定不可能全部写在一个包里面的。因此，根据不同功能或者形式来区分不同的模块。然后再根据模块的深度进行层次划分。模块中的业务的部分属于最上层，模块中的数据逻辑属于service层，模块中底层依赖(
比如第三方的sdk或者自己的sdk)
属于最底层。最后最底层的模块代码在与服务端通信和交互。完成整个模块的运行。这样划分，既保证了模块的独立性也保证了项目的层次架构。此外，模块化是一个复杂项目的必然追求，必须通过切分成一个个小的系统来达到各个突破的目的。每个模块可以单独开发、编译、测试，修改部分代码而不需要重新编译整个项目。
疑问：》？？ 氧气代码全量编译那么久，如何保证编译加快？ 最好是避免触发全量编译的次数，但有需要clean的时候，怎么优化呢？ 答：可以单独对某个模块进行clean！！ 牛啊 可以试试。
当真正触发全量编译过程的时候，如何优化㺡编译？？

c++语言中也是一样，肯定也会划分不同模块和层次。 flutter语言中也会这样，不同的模块，然后构建不同的层次，其中会涉及到业务、插件、包等层次划分。
有了不同模块，那么一个模块引用到了定义在另一个模块中的变量或者函数，就需要在运行前确定该变量或者函数的地址。这一步由链接来完成。

- Android中关链接的随想 app依赖某些sdk，如a和b sdk，a sdk又依赖某个b sdk。sdk其实是已经编译好了目标文件(也就是.class文件)
  ，如果b的版本不一致，则会选择最新版本进行下载到本地。 当app模块编译完成后，要跟a、b sdk进行链接，此时如果版本过低(通过版本指定)，则会导致app对b的引用出现不一致，会报错。
  疑问：？？ aar打包过程有没有包含链接过程？？ 我的理解：没有！ 因为aar首先不是可执行文件，因此，只完成了编译的部分(通过compileOnly
  来完成依赖，编译打包过程不报错，但是运行期间会报错，因为找不到。)。而apk打包过程则不一样，即完成了编译也完成了链接
  (也就是确定了每个符号的运行期地址)
  ，所以apk能跑起来。

链接的过程： 在引用到其他模块中的符号时候，编译器会先搁置，把目标地址设为0。接着链接器会把AB两个目标文件连接起来，指向该变量的地址重新定位到引用模块的真正的目标地址上，最终完成指正的目标地址调整。





  
































































